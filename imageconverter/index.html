<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="UTF-8">
		<link rel="manifest" href="/manifest.json">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0">
		<script>
			appname = "Compress Image"
		</script>
		<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
		<script src="/jsappapi/latest/main.js"></script>
		<style>
			.image-container {
				display: flex;
				gap: 20px;
				margin: 20px 0;
			}

			.image-preview {
				min-height: 100px;
				min-width: 100px;
				max-width: 300px;
				max-height: 300px;
				border: 1px solid var(--border);
				border-radius: 5px;
				padding: 5px;
				object-fit: contain;
				background-color: var(--background2);
			}

			.controls {
				margin: 15px 0;
				display: flex;
				gap: 20px;
				align-items: center;
			}

			.size-info {
				margin-top: 8px;
				font-size: 0.9em;
				color: var(--foreground2);
			}

			input[type="checkbox"] {
				accent-color: var(--accent);
			}
		</style>
	</head>

	<body>
		<header>
			<p1 id="header"></p1>
		</header>
		<div class="container">
			<input type="file" id="fileInput" accept="image/*">
			<div class="controls">
				<div class="quality-control">
					<input type="range" id="qualitySlider" min="1" max="100" value="80"><br>
					<p>Quality: <span id="qualityValue">80</span>%</p>
				</div>
			</div>
			<div class="image-container">
				<div>
					<p2>Original</p2>
					<img id="originalPreview" class="image-preview">
					<div class="size-info">Size: <span id="originalSize">-</span></div>
				</div>
				<div>
					<p2>Compressed</p2>
					<img id="webpPreview" class="image-preview">
					<div class="size-info">Size: <span id="webpSize">-</span></div>
				</div>
			</div>
			<a id="downloadLink" class="button main">Download compressed</a>
		</div>

		<script>
			const fileInput = document.getElementById('fileInput');
			const qualitySlider = document.getElementById('qualitySlider');
			const qualityValue = document.getElementById('qualityValue');
			const originalPreview = document.getElementById('originalPreview');
			const webpPreview = document.getElementById('webpPreview');
			const downloadLink = document.getElementById('downloadLink');
			const originalSize = document.getElementById('originalSize');
			const webpSize = document.getElementById('webpSize');

			let currentFile = null;
			let conversionTimeout = null;

			// Update controls and trigger conversion
			qualitySlider.addEventListener('input', updateQuality);
			fileInput.addEventListener('change', handleFileSelect);

			function updateQuality() {
				qualityValue.textContent = qualitySlider.value;
				triggerConversion();
			}

			async function handleFileSelect(e) {
				const file = e.target.files[0];
				if (!file) return;

				currentFile = file;
				originalPreview.src = URL.createObjectURL(file);
				originalSize.textContent = formatFileSize(file.size);
				triggerConversion();
			}

			function triggerConversion() {
				clearTimeout(conversionTimeout);
				conversionTimeout = setTimeout(convertImage, 300);
			}

			async function convertImage() {
				if (!currentFile) return;

				try {
					const quality = qualitySlider.value / 100;

					const webpBlob = await convertToWebp(currentFile, quality);

					webpPreview.src = URL.createObjectURL(webpBlob);
					webpSize.textContent = formatFileSize(webpBlob.size);

					const fileName = currentFile.name.replace(/\.[^/.]+$/, "") + '.webp';
					downloadLink.href = URL.createObjectURL(webpBlob);
					downloadLink.download = fileName;
					downloadLink.style.display = 'inline-block';
				} catch (error) {
					alert('Error converting image: ' + error.message);
				}
			}

			function formatFileSize(bytes) {
				if (bytes === 0) return '0 Bytes';
				const k = 1024;
				const sizes = ['Bytes', 'KB', 'MB', 'GB'];
				const i = Math.floor(Math.log(bytes) / Math.log(k));
				return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
			}

			async function convertToWebp(file, quality) {
				if (!checkWebpSupport()) {
					throw new Error('WebP conversion not supported in this browser');
				}

				return new Promise((resolve, reject) => {
					const img = new Image();
					img.onload = () => {
						const canvas = document.createElement('canvas');
						canvas.width = img.naturalWidth;
						canvas.height = img.naturalHeight;

						const ctx = canvas.getContext('2d');
						ctx.drawImage(img, 0, 0);

						const options = quality;

						canvas.toBlob(
							(blob) => blob ? resolve(blob) : reject(new Error('Conversion failed')),
							'image/webp',
							options
						);
					};
					img.onerror = () => reject(new Error('Error loading image'));
					img.src = URL.createObjectURL(file);
				});
			}

			function checkWebpSupport() {
				const canvas = document.createElement('canvas');
				return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
			}
		</script>
	</body>

</html>